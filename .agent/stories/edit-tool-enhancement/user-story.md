# Enhance `edit_file` with LLM-Driven Self-Correction

*This story addresses the problem of `edit_file` failing due to subtle inaccuracies (e.g., incorrect escaping, minor formatting differences) in `old_str` or `new_str` when generated by an LLM. The main objective is to make the `edit_file` tool more robust and reliable by enabling it to automatically correct problematic inputs before attempting file modification, thereby reducing `EDIT_NO_OCCURRENCE_FOUND` and `EDIT_EXPECTED_OCCURRENCE_MISMATCH` errors.*

## Requirements

*   **R1: Programmatic Unescaping:** The `edit_file` tool SHALL first attempt to unescape common LLM over-escaping patterns (e.g., `\\n` to `\n`, `\\"` to `"`) on both `old_str` and `new_str` before the primary replacement attempt.
*   **R2: LLM-Based `old_str` Correction:** IF the initial `old_str` (even after programmatic unescaping) results in `EDIT_NO_OCCURRENCE_FOUND` (0 occurrences), THEN `edit_file` SHALL make an internal LLM call to attempt to identify and correct the `old_str` to an exact match found in the file content.
*   **R3: LLM-Based `new_str` Adjustment:** IF `old_str` is successfully corrected by an LLM (as per R2), THEN `edit_file` SHALL make a second internal LLM call to adjust the `new_str` to ensure logical consistency and maintain the original intent of the edit, given the corrected `old_str`.
*   **R4: LLM-Based `new_str` Escaping Correction:** IF `new_str` (either original or LLM-adjusted) contains escaping issues that would result in incorrect output, THEN `edit_file` SHALL make an internal LLM call to correct its escaping, ensuring it's syntactically valid for insertion. This can run independently of R2/R3 if only `new_str` is problematic.
*   **R5: Preserve Atomic Operations:** All file modifications performed by `edit_file` (including after corrections) SHALL remain atomic, leveraging the existing temporary file and rename mechanism.
*   **R6: Maintain Error Granularity:** `edit_file` SHALL continue to return existing specific error codes (e.g., `EDIT_INVALID_PATH`, `EDIT_FILE_READ_ERROR`, `ATTEMPT_TO_CREATE_EXISTING_FILE`) for scenarios where correction is not applicable or fails to resolve the issue.
*   **R7: Respect `expected_replacements`:** The `expected_replacements` parameter SHALL be validated against the actual occurrences of the *final, corrected* `old_str`. If the corrected `old_str` leads to multiple occurrences when `expected_replacements` is 1, an error should still be returned, unless the correction strategy specifically handles this (e.g. by focusing on a unique match). For the scope of this story, if the LLM correction for `old_str` produces multiple matches and `expected_replacements` is 1, it should result in an error indicating mismatch.
*   **R8: No Regression:** All existing, correctly functioning `edit_file` use cases SHALL continue to work as before, without degradation or introduction of new errors.
*   **R9: Caching for LLM Calls (Optional but Recommended for Future):** Consider a simple in-memory cache for LLM correction results to reduce redundant LLM calls for identical problematic inputs. (This might be a follow-up story due to complexity of cache invalidation in Go, but worth noting now).

## Rules

*   **RL1: Correction Precedence:** Programmatic unescaping (R1) MUST be attempted before any LLM-based corrections (R2, R3, R4).
*   **RL2: Internal Correction:** The LLM correction mechanisms (R2, R3, R4) MUST be internal functions called by `EditFile` and SHALL NOT be exposed as separate callable tools to the agent.
*   **RL3: LLM Model Consistency:** All internal LLM correction calls SHOULD use the same model and configuration as the primary agent inference model unless specifically tuned otherwise for performance/accuracy.
*   **RL4: `new_str` Adjustment Logic:** `new_str` adjustment (R3) SHOULD only occur if `old_str` was successfully corrected by an LLM (R2) and the `original_old_string` differs from the `corrected_old_string`.
*   **RL5: Unique Match for `old_str` Correction:** The LLM prompt for `old_str` correction (R2) MUST explicitly instruct the LLM to find an "exact literal, unique match." If the LLM cannot confidently provide a unique match, it should return an empty or clearly erroneous response, leading to the original `EDIT_NO_OCCURRENCE_FOUND` error.

## Domain

```go
// Existing EditFileInput
type EditFileInput struct {
	Path               string `json:"path" jsonschema_description:"The path to the file"`
	OldStr             string `json:"old_str" jsonschema_description:"Text to search for - must match exactly and must only have one match exactly"`
	NewStr             string `json:"new_str" jsonschema_description:"Text to replace old_str with"`
	ExpectedReplacements *int   `json:"expected_replacements,omitempty" jsonschema_description:"Optional: The expected number of replacements. If actual replacements differ, an error is returned."`
}

// Internal structure to hold corrected parameters (similar to CorrectedEditParams in TS)
type CorrectedEditResult struct {
    FilePath string
    OldString string
    NewString string
    Occurrences int
}

// Proposed new internal function signatures for LLM correction
// These will encapsulate the LLM prompting and parsing
func correctOldStringMismatchLLM(ctx context.Context, fileContent, problematicOldStr string) (string, error)
func correctNewStringLLM(ctx context.Context, originalOldStr, correctedOldStr, originalNewStr string) (string, error)
func correctStringEscapingLLM(ctx context.Context, potentiallyProblematicString string) (string, error)

// Proposed new utility for programmatic unescaping
func unescapeGoString(inputString string) string
```

## Extra Considerations

*   **Performance Impact:** Each LLM correction step introduces additional latency. While beneficial for correctness, monitor overall agent execution time. Caching (R9) could mitigate this.
*   **LLM Hallucinations:** There's a risk of the LLM generating incorrect corrections. The prompts for correction must be meticulously crafted to minimize this, emphasizing "exact, literal match" and "maintaining original intent."
*   **Complexity Management:** Integrating multiple correction layers adds complexity to `EditFile`. Ensure the logic is clearly structured and well-commented.
*   **Prompt Engineering:** The quality of LLM corrections is heavily dependent on the prompts. Iteration and refinement of these internal prompts will be crucial.
*   **Go Context:** Ensure that LLM calls within the `edit_file` function respect the `context.Context` for timeouts and cancellation.
*   **Error Bubbling:** Clearly define how errors from correction attempts should propagate. If a correction attempt fails, `edit_file` should fall back to reporting the original, uncorrectable error.
*   **External File Modifications:** The TypeScript code had `findLastEditTimestamp` to detect external edits. While highly desirable, this is complex to implement robustly in Go (requires Git knowledge, timestamp tracking). This is **out of scope** for this story but a potential future enhancement for greater robustness.

## Testing Considerations

*   **Unit Tests for `unescapeGoString`:**
    *   Test cases: `\\n` -> `\n`, `\\t` -> `\t`, `\\\"` -> `\"`, `\\\\` -> `\\`, mixed escaped and unescaped strings, strings with no escaping, empty string.
*   **Integration Tests for `EditFile`:**
    *   **Baseline Success:** Verify existing simple replacements work unchanged.
    *   **Programmatic Unescaping Success (R1):**
        *   `old_str` with `\\n` replaced with `\n` in file.
        *   `new_str` with `\\n` successfully written as `\n`.
    *   **LLM `old_str` Correction Success (R2):**
        *   Test a scenario where `old_str` has minor differences (e.g., extra space, missing escape) that the LLM can correct to a unique match.
    *   **LLM `old_str` and `new_str` Adjustment Success (R3):**
        *   Test `old_str` corrected, and `new_str` adjusted accordingly (e.g., if `old_str` gained a newline, `new_str` also gains one to match intent).
    *   **LLM `new_str` Escaping Correction Success (R4):
        *   Test `edit_file` with `new_str` containing `\\n` which should be written as `\n`.
    *   **Correction Failure - `old_str` not found (0 occurrences):**
        *   Test a problematic `old_str` that cannot be corrected by programmatic unescaping *or* LLM, leading to `EDIT_NO_OCCURRENCE_FOUND`.
    *   **Correction Failure - `expected_replacements` mismatch:**
        *   Test a corrected `old_str` that leads to more than one match when `expected_replacements` is set to 1.
    *   **Edge Cases:**
        *   Multi-line `old_str` and `new_str`.
        *   `old_str` or `new_str` being very long.
        *   File creation (where `old_str` is empty).
        *   Empty files.
*   **Mock LLM Client:** For faster and deterministic testing, consider mocking the LLM client responses for the `correctOldStringMismatchLLM`, `correctNewStringLLM`, and `correctStringEscapingLLM` functions. This allows testing correction logic without actual API calls.

## Implementation Notes

*   **New Package/File:** Create a new Go package, e.g., `internal/editcorrector`, to house the `unescapeGoString` function and the LLM correction logic (`correctOldStringMismatchLLM`, `correctNewStringLLM`, `correctStringEscapingLLM`). This keeps `main.go` cleaner.
*   **LLM Integration:** The LLM calls within the new correction functions should leverage the `openai.Client` instance available through the `Agent` struct.
*   **JSON Schema for LLM Prompts:** Define Go structs that represent the JSON schemas for the expected LLM responses (e.g., `CorrectedOldStringResponse`, `CorrectedNewStringResponse`). Use `jsonschema.Reflect` as currently done for tool schemas.
*   **Prompt Crafting:** The LLM prompts for `correctOldStringMismatchLLM`, `correctNewStringLLM`, and `correctStringEscapingLLM` are critical. They should be carefully translated from the spirit of the TypeScript prompts, emphasizing "exact literal match," "maintaining intent," and "correcting syntax/escaping."
*   **Error Handling in Correction Chain:** Design the flow within `EditFile` to gracefully handle errors returned by the correction functions. If a correction fails, it should default back to the original `EditFileInput` values and then allow the standard `EditFile` error handling to take over.
*   **Pass Context:** Ensure `context.Context` is passed down to all new functions making LLM calls to enable proper timeout and cancellation.
*   **Logging:** Add detailed internal logging for when corrections are attempted, whether they succeed, and what the corrected values are. This will be invaluable for debugging.

## Specification by Example

**Example 1: Programmatic Unescaping of `old_str`**

**Initial `edit_file` call:**
```python
default_api.edit_file(
    path="my_file.txt",
    old_str="print(\"Hello\\nWorld\")",
    new_str="print(\"Hello New World\")",
    expected_replacements=1
)
```
**`my_file.txt` content:**
```
print("Hello
World")
```
**Expected Behavior:**
1.  `edit_file` attempts to find `"print(\"Hello\\nWorld\")"` in `my_file.txt`. Fails.
2.  `edit_file` calls `unescapeGoString("print(\"Hello\\nWorld\")")` which returns `"print(\"Hello\nWorld\")"`.
3.  `edit_file` re-attempts to find `"print(\"Hello\nWorld\")"`. Succeeds, 1 occurrence found.
4.  `new_str` `"print(\"Hello New World\")"` is used.
5.  File is updated.

**Example 2: LLM Correction for `old_str` and `new_str` Adjustment**

**Initial `edit_file` call:**
```python
default_api.edit_file(
    path="config.js",
    old_str="const API_URL = 'https://old.api/v1';",
    new_str="const API_URL = 'https://new.api/v2';",
    expected_replacements=1
)
```
**`config.js` content:**
```javascript
// Existing content in config.js
const API_URL = "https://old.api/v1"; // Note: double quotes, missing semicolon
```
**Expected Behavior:**
1.  `edit_file` attempts to find `"const API_URL = 'https://old.api/v1';"` in `config.js`. Fails (due to double quotes and missing semicolon in file).
2.  Programmatic unescaping might not fully resolve this.
3.  `edit_file` calls `correctOldStringMismatchLLM("config.js content", "const API_URL = 'https://old.api/v1';")`.
4.  LLM returns `{"corrected_target_snippet": "const API_URL = \"https://old.api/v1\""}`.
5.  `edit_file` re-attempts to find `"const API_URL = \"https://old.api/v1\""`. Succeeds, 1 occurrence found.
6.  `edit_file` calls `correctNewStringLLM("const API_URL = 'https://old.api/v1';", "const API_URL = \"https://old.api/v1\"", "const API_URL = 'https://new.api/v2';")`.
7.  LLM returns `{"corrected_new_string": "const API_URL = \"https://new.api/v2\""}`.
8.  File is updated using the corrected `old_str` and `new_str`.

## Verification

- [ ] The `unescapeGoString` function is implemented and unit tested for all specified cases.
- [ ] The `correctOldStringMismatchLLM` function is implemented, including LLM prompting and JSON response parsing.
- [ ] The `correctNewStringLLM` function is implemented, including LLM prompting and JSON response parsing.
- [ ] The `correctStringEscapingLLM` function is implemented, including LLM prompting and JSON response parsing.
- [ ] The `EditFile` function incorporates the programmatic unescaping (R1).
- [ ] The `EditFile` function implements the LLM-based `old_str` correction logic (R2).
- [ ] The `EditFile` function implements the LLM-based `new_str` adjustment logic (R3).
- [ ] The `EditFile` function implements the LLM-based `new_str` escaping correction logic (R4).
- [ ] All file operations in `EditFile` remain atomic (R5).
- [ ] Existing `EditFile` error handling (e.g., `EDIT_FILE_NOT_FOUND`, `ATTEMPT_TO_CREATE_EXISTING_FILE`) remains functional (R6).
- [ ] The `expected_replacements` parameter is correctly honored with corrected strings (R7).
- [ ] Comprehensive integration tests are added to cover all successful correction scenarios and defined failure modes.
- [ ] No regressions are introduced to existing `edit_file` functionalities (R8).